# -*- coding: utf-8 -*-
"""Capstone Project 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QV-ng42uvxvTEQ0DvdQTlDdLw7PQ-S36

# Inspection and Making Categories
"""

import numpy as np
import pandas as pd

# !pip install pathway    # uncomment out this while running, this module gets deleted once session restarts

import pathway as pw

df = pd.read_csv("dataset.csv")   # uploading data

df.head()  # there are a total of 73x18 entries of data for each parking lot

df.info()   # to get a breif idea of overall data

df.describe()   # to get some imp terms

df.isna().sum()  # great, no values are missing

num_cols = ["ID", "Capacity", "Latitude", "Longitude","Occupancy","QueueLength","IsSpecialDay"]
obj_cols = ["SystemCodeNumber","VehicleType","TrafficConditionNearby","LastUpdatedDate","LastUpdatedTime"]

for i in range(len(num_cols)) :     # so we now know which ones to create categories
  print(f"{num_cols[i]} : {df[num_cols[i]].nunique()}")

for i in range(len(obj_cols)) :  # same here
  print(f"{obj_cols[i]} : {df[obj_cols[i]].nunique()}")

!pip install pathway bokeh --quiet

import matplotlib.pyplot as plt
import datetime
from datetime import datetime

import bokeh.plotting
import panel as pn

# Combine the "LastUpdatedDate" and "LastUpdatedTime" columns into a single datetime column
df["Timestamp"] = pd.to_datetime(df["LastUpdatedDate"]+ " " + df["LastUpdatedTime"], format = "%d-%m-%Y %H:%M:%S")

# Sort the Dataframe by the new "Timestamp" column and reset the index
df = df.sort_values("Timestamp").reset_index(drop = True)

df   # now we have values all parking slots together at diff times of day

# making categories

Vehicle_Weights = {
    "car" : 2,
    "bike" : 1,
    "cycle" : 1,
    "truck" : 3
}

Traffic_Weights = {
    "low" : 1,
    "medium" : 2,
    "high" : 3
}

# creating new columns using function map

df["VehicleWeight"] = df["VehicleType"].map(Vehicle_Weights)
df["TrafficWeight"] = df["TrafficConditionNearby"].map(Traffic_Weights)

df

df.drop(["LastUpdatedTime","LastUpdatedDate","TrafficConditionNearby","VehicleType"],axis =1, inplace = True)

df

"""# MODEL 1 - Linear"""

df[["Timestamp", "Occupancy", "Capacity", "QueueLength","Latitude","Longitude","IsSpecialDay","VehicleWeight","TrafficWeight"]].to_csv("parking_stream.csv", index = False)

class ParkingSchema(pw.Schema):   # made a new Schema with these columns
  Timestamp : str
  Occupancy : float
  Capacity : int
  QueueLength : int
  Latitude : float
  Longitude : float
  IsSpecialDay : int
  VehicleWeight : int
  TrafficWeight : int

# making a table using Schema made above with real-time data preprocessing from the saved csv file

data_2 = pw.demo.replay_csv("parking_stream.csv", schema = ParkingSchema, input_rate = 1000)

fmt = "%Y-%m-%d %H:%M:%S"

# Add new columns to the data_2 stream:
# - 't' contains the parsed full datetime
# - 'day' extracts the date part and resets the time to midnight (useful for day-level aggregations)
data_with_time = data_2.with_columns(
    t = data_2.Timestamp.dt.strptime(fmt),
    day = data_2.Timestamp.dt.strptime(fmt).dt.strftime("%Y-%m-%dT00:00:00")
)

df

df = pd.read_csv("parking_stream.csv")

df.columns

# define a daily tumbling window over the data stream using Pathway
# this block performs temporal aggregation and computes a dynamic price for each day
import datetime


delta_window = (
    data_with_time.windowby(
        pw.this.t,  # Event time column to use for windowing (parsed datetime)
        instance=pw.this.day,  # Logical partitioning key: one instance per calendar day
        window=pw.temporal.tumbling(datetime.timedelta(days=1)),  # Fixed-size daily window
        behavior=pw.temporal.exactly_once_behavior()  # Guarantees exactly-once processing semantics
    )
    .reduce(
        t=pw.this._pw_window_end,                        # Assign the end timestamp of each window
        occ_max=pw.reducers.max(pw.this.Occupancy),      # Highest occupancy observed in the window
        occ_min=pw.reducers.min(pw.this.Occupancy),      # Lowest occupancy observed in the window
        cap=pw.reducers.max(pw.this.Capacity),           # Maximum capacity observed (typically constant per spot)
    )
    .with_columns(
        # Compute the price using a simple dynamic pricing formula:
        #
        # Pricing Formula:
        #     price = base_price + demand_fluctuation
        #     where:
        #         base_price = 10 (fixed minimum price)
        #         demand_fluctuation = (occ_max - occ_min) / cap
        #
        # Intuition:
        # - The greater the difference between peak and low occupancy in a day,
        #   the more volatile the demand is, indicating potential scarcity.
        # - Dividing by capacity normalizes the fluctuation (to stay in [0,1] range).
        # - This fluctuation is added to the base price of 10 to set the final price.
        # - Example: If occ_max = 90, occ_min = 30, cap = 100
        #            => price = 10 + (90 - 30)/100 = 10 + 0.6 = 10.6

        price=10 + (pw.this.occ_max - pw.this.occ_min) / pw.this.cap
    )
)

# Activate the Panel extension to enable interactive visualizations
pn.extension()

# Define a custom Bokeh plotting function that takes a data source (from Pathway) and returns a figure
def price_plotter(source):
    # Create a Bokeh figure with datetime x-axis
    fig = bokeh.plotting.figure(
        height=400,
        width=800,
        title="Pathway: Daily Parking Price(Linear Variation)",
        x_axis_type="datetime",  # Ensure time-based data is properly formatted on the x-axis
    )
    # Plot a line graph showing how the price evolves over time
    fig.line("t", "price", source=source, line_width=2, color="navy")

    # Overlay red circles at each data point for better visibility
    fig.circle("t", "price", source=source, size=6, color="red")

    return fig

# Use Pathway's built-in .plot() method to bind the data stream (delta_window) to the Bokeh plot
# - 'price_plotter' is the rendering function
# - 'sorting_col="t"' ensures the data is plotted in time order
viz = delta_window.plot(price_plotter, sorting_col="t")

# Create a Panel layout and make it servable as a web app
# This line enables the interactive plot to be displayed when the app is served
pn.Column(viz).servable()

pw.run()

"""# MODEL 2 - Demand Based"""

delta_window = (
     data_with_time.windowby(
         pw.this.t,  # Event time column to use for windowing (parsed datetime)
         instance=pw.this.day,  # Logical partitioning key: one instance per calendar day
         window=pw.temporal.tumbling(datetime.timedelta(days=1)),  # Fixed-size daily window
         behavior=pw.temporal.exactly_once_behavior()  # Guarantees exactly-once processing semantics
     )
     .reduce(
         t=pw.this._pw_window_end,                        # Assign the end timestamp of each window
         cap=pw.reducers.max(pw.this.Capacity),           # Maximum capacity observed (typically constant per spot)
         count = pw.reducers.count(),
         special_day = pw.reducers.max(pw.this.IsSpecialDay),
         occ_sum = pw.reducers.sum(pw.this.Occupancy),
         queue_sum = pw.reducers.sum(pw.this.QueueLength),
         traffic_sum = pw.reducers.sum(pw.this.TrafficWeight),
         vehicle_sum = pw.reducers.sum(pw.this.VehicleWeight),

         demand_min = pw.reducers.min(
            0.4 * (pw.this.Occupancy / pw.this.Capacity) +
            0.2 * pw.this.QueueLength -
            0.3 * pw.this.TrafficWeight +
            0.5 * pw.this.IsSpecialDay +
            1.0 * pw.this.VehicleWeight
        ),
        demand_max = pw.reducers.max(
            0.4 * (pw.this.Occupancy / pw.this.Capacity) +
            0.2 * pw.this.QueueLength -
            0.3 * pw.this.TrafficWeight +
            0.5 * pw.this.IsSpecialDay +
            1.0 * pw.this.VehicleWeight)

)
.with_columns(
    occ_avg = pw.this.occ_sum / pw.this.count,
    queue_avg = pw.this.queue_sum / pw.this.count,
    traffic_avg = pw.this.traffic_sum / pw.this.count,
    vehicle_avg = pw.this.vehicle_sum / pw.this.count,

    demand = (
        0.4 * (pw.this.occ_sum / pw.this.count / pw.this.cap) +
        0.2 * (pw.this.queue_sum / pw.this.count) -
        0.3 * (pw.this.traffic_sum / pw.this.count) +
        0.5 * pw.this.special_day +
        1.0 * (pw.this.vehicle_sum / pw.this.count)
    ),

    price_model2 = 10 + 0.5 * (
        (
            0.7 * (pw.this.occ_sum / pw.this.count / pw.this.cap) +
            0.2 * (pw.this.queue_sum / pw.this.count) -
            0.3 * (pw.this.traffic_sum / pw.this.count) +
            0.5 * pw.this.special_day +
            1.0 * (pw.this.vehicle_sum / pw.this.count)
            - pw.this.demand_min
        ) / (pw.this.demand_max - pw.this.demand_min + 1e-6)
    )
)
)

# Activate the Panel extension to enable interactive visualizations
pn.extension()

# Define a custom Bokeh plotting function that takes a data source (from Pathway) and returns a figure
def price_plotter(source):
    # Create a Bokeh figure with datetime x-axis
    fig = bokeh.plotting.figure(
        height=400,
        width=800,
        title="Pathway: Daily Parking Price (Demand Based)",
        x_axis_type="datetime",  # Ensure time-based data is properly formatted on the x-axis
    )
    # Plot a line graph showing how the price_model2 evolves over time
    fig.line("t", "price_model2", source=source, line_width=2, color="navy")

    # Overlay red circles at each data point for better visibility
    fig.circle("t", "price_model2", source=source, size=6, color="red")

    return fig

# Use Pathway's built-in .plot() method to bind the data stream (delta_window) to the Bokeh plot
# - 'price_model2_plotter' is the rendering function
# - 'sorting_col="t"' ensures the data is plotted in time order
viz = delta_window.plot(price_plotter, sorting_col="t")

# Create a Panel layout and make it servable as a web app
# This line enables the interactive plot to be displayed when the app is served
pn.Column(viz).servable()

pw.run()

